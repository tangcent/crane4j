## 安装

### 引入依赖

在非 spring 环境中，引入 `crane4j-core` 模块即可：

~~~xml
<dependency>
    <groupId>cn.crane4j</groupId>
    <artifactId>crane4j-core</artifactId>
    <version>${last-version}</version>
</dependency>
~~~

> 当前最新版本为 ![maven-central](https://img.shields.io/github/v/release/Createsequence/crane4j?include_prereleases)

### 全局配置

`crane4j` 类似于其他框架，也提供了一个全局配置类 `Crane4jGlobalConfiguration`，类似于 MyBatis 的 `Configuration`，用于管理 `crane4j` 的各种组件。在非 Spring 环境下，由于没有自动装配的功能，推荐使用 `SimpleCrane4jGlobalConfiguration.create` 工厂方法以默认配置创建一个实例：

```java
// 创建一个默认配置类
Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create();
```

用户需要自行保存 `Crane4jGlobalConfiguration` 实例，通常它应该是全局单例的。

### 启用填充工具

获得了 `Crane4jGlobalConfiguration` 实例后，用户可以创建一个 `OperateTemplate` 工具类，它可以方便地完成填充操作：

```java
// 基于默认的配置解析器与执行器创建 OperateTemplate
OperateTemplate template = new OperateTemplate(
    configuration.getBeanOperationsParser(BeanOperationParser.class),
    configuration.getBeanOperationExecutor(BeanOperationExecutor.class),
    configuration.getTypeResolver()
);
```

与 `Crane4jGlobalConfiguration` 一样，`OperateTemplate` 也应该是单例的。

### 启用扩展功能

在非 Spring 环境下，由于缺少自动化的后处理和 AOP 等能力，因此 `crane4j` 的一些扩展功能需要用户自行启用：

1. 自动填充方法的入参：`MethodArgumentAutoOperateSupport`；
2. 自动填充方法的返回值：`MethodResultAutoOperateSupport`；
3. 方法数据源容器适配：`ContainerMethodAnnotationProcessor`；
4. 容器的缓存功能：`DefaultCacheableContainerProcessor`；

这些扩展功能需要用户根据需求进行配置和启用，如有疑问，可以参考文档或测试用例，也可以直接咨询作者。

## 配置数据源

在 `crane4j` 中，一个数据源对应一个**数据源容器**，因此在进行填充操作之前，需要先准备好相应的数据源容器。

下面是一个简单的示例，配置了一个命名空间为 `gender` 的数据源容器，根据 0 或 1 返回对应的性别名称：

```java
// 注册性别信息数据源
Map<Integer, String> sources = new HashMap<>();
sources.put(0, "女");
sources.put(1, "男");
Container<String> genderContainer = Containers.forMap("gender", sources);
```

接下来，我们将该容器注册到之前创建的全局配置类 `SimpleCrane4jGlobalConfiguration` 中：

```java
Crane4jGlobalConfiguration configuration = // 前文创建的 SimpleCrane4jGlobalConfiguration 实例
configuration.registerContainer(genderContainer);
```

:::tip
- 注册数据源的步骤也可以放在 `ApplicationRunner` 或者用 `@PostConstruct` 注解的回调方法中执行。
- 除了处理简单的本地缓存外，`crane4j` 也支持创建其他类型的数据源容器，具体内容可以参考后文关于数据源容器的部分

:::

## 配置装配操作

在`crane4j`中，**装配操作**是指对某个对象的填充行为。我们可以通过在类或属性上添加注解来配置装配操作。

例如，在`Student`类中声明了一个装配操作：

- 该操作基于`sex`字段的值来执行，即根据`sex`字段的值查找关联数据。
- 从命名空间为`gender`的数据源容器获取关联数据。
- 将获取的关联数据直接赋值给`sexName`引用字段。

~~~java
@RequiredArgsConstructor // 使用 lombok 生成 get 方法和构造器
@Getter
@Setter
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
}
~~~

以上配置表示根据`sex`字段从`gender`数据源容器中查找对应的男/女名称，并映射到`sexName`字段上。

:::tip

- `@Assemble` 注解用于声明一次填充操作，具体参见后文[装配操作](./../operation/3.1.声明装配操作.md)一节；
- `@Mapping` 用于指明数据源对象上的字段要如何映射到待处理对象的字段上，具体参见后文[字段映射](./../operation/3.4.配置字段映射.md)一节；

:::

## 执行装配操作

在项目启动后，用户可以直接通过上文创建的填充工具类 `OperateTemplate` 去填充我们已经配置过的对象：

~~~java
OperateTemplate operateTemplate  = // 用户自己保存的 OperateTemplate 实例
List<Student> students = Arrays.asList(
    new Student("小红", 1), new Student("小明", 2)
);
operateTemplate.execute(students);
~~~

在执行后，`students` 中对象的 `sexName` 将根据 `sex` 字段的值被填充：

~~~java
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
    }
]
~~~

## 执行嵌套填充

当我们需要填充嵌套对象时，除了为嵌套字段声明装配操作外，还需要为需要填充的嵌套字段声明**拆卸操作**。

例如，`Student`对象中嵌套了一个需要填充的`StudentClass`对象。该对象需要通过 id 从命名空间为 `student-class` 的数据源容器获取数据源对象的 `name` 属性，并将其填充到自己的 `name` 字段上。

除了为 `StudentClass` 类声明装配操作外，我们还需要在 `Student` 的 `studentClass` 属性上通过注解声明一个拆卸操作：

~~~java
@RequiredArgsConstructor
@Data
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
    
    // 声明一个拆卸操作，拆卸后需要填充的对象类型为 StudentClass
    // 字段类型可以是单个对象，数组或者 Collection 集合
    @Disassemble(type = StudentClass.class)
    private final StudentClass studentClass; 
}

@RequiredArgsConstructor
@Data
public class StudentClass {
    @Assemble(container = "student-class", @Props = @Mapping("name"))
    private final Integer id;
    private String name;
}
~~~

以上配置表示，在执行装配操作之前，我们需要先将 `Student` 中的 `StudentClass` 取出并摊平，然后再完成所有待处理的 `Student` 和 `StudentClass` 对象的装配操作。

我们依然在项目启动后执行下述代码：

~~~java
OperateTemplate operateTemplate = // 用户自己保存的 OperateTemplate 实例
List<Student> students = Arrays.asList(
    new Student("小红", "0", new StudentClass(1)), new Student("小明", "1", new StudentClass(2))
);
operateTemplate.execute(students);
~~~

执行后，`students` 中的 `Student` 对象及嵌套的 `StudentClass` 对象将会被填充：

~~~json
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
        "studentClass": {
            "id": 1,
            "name": "一年1班"
        }
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
        "studentClass": {
            "id": 2,
            "name": "一年2班"
        }
    }
]
~~~